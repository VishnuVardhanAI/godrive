// Package main implements the Auth gRPC service for GoDrive.
// Responsibilities:
//   - Create users with securely hashed passwords (bcrypt)
//   - Authenticate users and mint short-lived JWT access tokens (HS256)
//   - Verify JWTs for the gateway (returns user info on success)
//
// Notes:
//   - JWTs are signed (integrity/authenticity) but not encrypted; keep claims minimal.
//   - We keep migrations minimal here for dev; switch to a migrator in prod.

package main

import (
	"context"         // request-scoped cancellation, DB timeouts later
	"crypto/rand"     // random bytes for default JWT secret in dev
	"encoding/base64" // encode secret if we auto-generate one
	"log"             // basic logging; replace with structured logs later
	"net"             // TCP listener for the gRPC server
	"os"              // env config (12-factor style)
	"time"            // timestamps and JWT expiry

	"github.com/golang-jwt/jwt/v5"                // JWT creation/verification
	"github.com/jackc/pgx/v5/pgxpool"             // Postgres connection pool
	gv1 "github.com/you/godrive/proto/godrive/v1" // generated gRPC stubs
	"golang.org/x/crypto/bcrypt"                  // password hashing
	"google.golang.org/grpc"                      // gRPC server
)

// server implements gv1.AuthServiceServer. It holds its dependencies.
// We prefer explicit deps on a struct for testability.
type server struct {
	gv1.UnimplementedAuthServiceServer // forward-compatible embed

	db        *pgxpool.Pool // pooled Postgres connections
	jwtSecret []byte        // HMAC key for HS256 JWTs (read from env)
}

func main() {
	// Read configuration from environment (or fall back to dev defaults).
	dsn := env("DB_DSN", "postgres://godrive:godrive@localhost:5432/godrive?sslmode=disable")
	secret := []byte(env("JWT_SECRET", randSecret()))

	// Connect to Postgres using a connection pool.
	pool, err := pgxpool.New(context.Background(), dsn)
	if err != nil {
		log.Fatal(err)
	}

	// Create the users table if it doesn't exist (dev convenience).
	if err := migrate(pool); err != nil {
		log.Fatal(err)
	}

	// Construct our gRPC server and register the Auth service implementation.
	s := &server{db: pool, jwtSecret: secret}
	grpcSrv := grpc.NewServer()
	gv1.RegisterAuthServiceServer(grpcSrv, s)

	// Bind to TCP :50051 and start serving.
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatal(err)
	}

	log.Println("auth service on :50051")

	if err := grpcSrv.Serve(lis); err != nil {
		log.Fatal(err)
	}
}

// SignUp creates a new user with a bcrypt-hashed password.
// Input: Credentials{email, password}
// Output: User{id, email, created_at}
func (s *server) SignUp(ctx context.Context, in *gv1.Credentials) (*gv1.User, error) {
	// Always hash passwords; never store plaintext.
	hash, err := bcrypt.GenerateFromPassword([]byte(in.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	// Insert user and return primary key.
	var id int64
	err = s.db.QueryRow(
		ctx,
		`INSERT INTO users(email, password_hash) VALUES(lower($1), $2) RETURNING id`,
		in.Email,
		string(hash),
	).Scan(&id)
	if err != nil {
		// If the email already exists, Postgres raises an error due to UNIQUE constraint.
		return nil, err
	}

	// Build response. created_at is generated by DB; we present a client-friendly ISO string.
	return &gv1.User{
		Id:        id,
		Email:     in.Email,
		CreatedAt: time.Now().UTC().Format(time.RFC3339),
	}, nil
}

// Login verifies user credentials and issues a signed JWT access token.
// Input: Credentials{email, password}
// Output: Token{access_token, expires_at}
func (s *server) Login(ctx context.Context, in *gv1.Credentials) (*gv1.Token, error) {
	// Look up hashed password for the given email.
	var (
		id   int64
		hash string
	)

	err := s.db.QueryRow(
		ctx,
		`SELECT id, password_hash FROM users WHERE email = lower($1)`,
		in.Email,
	).Scan(&id, &hash)
	if err != nil {
		return nil, grpcErr("invalid credentials")
	}

	// Compare supplied password with stored bcrypt hash (constant-time).
	if err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(in.Password)); err != nil {
		return nil, grpcErr("invalid credentials")
	}

	// Create a short-lived access token (here 7 days for dev; shorten in prod).
	exp := time.Now().Add(7 * 24 * time.Hour)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"uid": id,                // our user identifier
		"exp": exp.Unix(),        // expiry (required)
		"iat": time.Now().Unix(), // issued at
		// Optional hardening:
		// "iss": "godrive-auth", // who created the token
		// "aud": "godrive-client", // intended audience
	})

	signed, err := token.SignedString(s.jwtSecret)
	if err != nil {
		return nil, err
	}

	return &gv1.Token{
		AccessToken: signed,
		ExpiresAt:   exp.Format(time.RFC3339),
	}, nil
}

// Verify parses and validates a JWT. If valid, it returns minimal user info.
// We delegate verification to Auth so only this service needs to know the secret.
func (s *server) Verify(ctx context.Context, tok *gv1.Token) (*gv1.User, error) {
	claims := jwt.MapClaims{}

	// Parse the token and verify signature using our HMAC secret.
	_, err := jwt.ParseWithClaims(tok.AccessToken, claims, func(t *jwt.Token) (interface{}, error) {
		return s.jwtSecret, nil
	})
	if err != nil {
		return nil, grpcErr("invalid token")
	}

	// Extract our custom claim (uid). Note: JSON numbers decode as float64.
	uid := int64(claims["uid"].(float64))

	// Optionally fetch email to return alongside id.
	var email string
	_ = s.db.QueryRow(ctx, `SELECT email FROM users WHERE id = $1`, uid).Scan(&email)

	return &gv1.User{
		Id:    uid,
		Email: email,
		// CreatedAt omitted here; not needed for Verify
	}, nil
}

// migrate creates the users table if it doesn't exist. Dev convenience only.
func migrate(p *pgxpool.Pool) error {
	_, err := p.Exec(context.Background(), `
CREATE TABLE IF NOT EXISTS users (
  id BIGSERIAL PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);`)
	if err != nil {
		return err
	}

	return nil
}

// env reads an environment variable or returns the provided default.
func env(k, d string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}

	return d
}

// randSecret generates a URL-safe random string used as a fallback JWT secret in dev.
func randSecret() string {
	b := make([]byte, 32)
	_, _ = rand.Read(b)

	return base64.RawURLEncoding.EncodeToString(b)
}

// must is a tiny helper for fatal error handling during startup.
func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

// grpcErr returns a generic Unauthenticated gRPC error.
// In production, consider returning typed errors with status/codes.
func grpcErr(msg string) error {
	return grpc.Errorf(16, msg) // codes.Unauthenticated = 16
}
